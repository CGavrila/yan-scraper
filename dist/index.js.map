{"version":3,"sources":["src/index.js"],"names":[],"mappings":"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","file":"src/index.js","sourcesContent":["'use strict';\n\nimport Deque from 'collections/deque';\nimport * as request from 'request';\nimport _ from 'lodash';\nimport * as cheerio from 'cheerio';\nvar debug = require('debug')('Scraper');\nvar EventEmitter = require('events').EventEmitter;\n\nlet _singleton = Symbol();\n\n/**\n *\n * Singleton class used to scrape websites based on templates and a queue.\n *  - the queue contains the URLs which will be retrieved and then processed as defined by its matching template\n *  - a template is a set of rules which dictate how often a certain type of website can be accessed and what\n *    happens with its response\n *\n * A more hands-on example:\n * You want to scrape data from amazon.com, so what you have to do is to instantiate the Scraper class, add a template\n * and then a couple of pages in the queue that you want scraped.\n *\n * ------------------------------------------------------------------------\n * var scraper = Scraper.instance;\n * scraper.addTemplate({\n *   name: 'Amazon',\n *   matchesFormat: function(url) {\n *       return url.toLowerCase().indexOf('amazon.com') !== -1;\n *   },\n *   callback: function(body, $) {\n *       return { body: body, provider: 'CNN' };\n *   },\n *   interval: 1000\n * });\n *\n * scraper.queue('https://www.amazon.com/product/whatever');\n * ------------------------------------------------------------------------\n *\n */\nclass Scraper extends EventEmitter {\n\n    constructor(singletonToken) {\n        super();\n        if (_singleton !== singletonToken)\n            throw new Error('Scraper is a singleton class, cannot instantiate directly.');\n\n        this.templates = {};\n        this.deque = new Deque();\n        this.options = {};\n    }\n\n    static get instance() {\n        if(!this[_singleton])\n            this[_singleton] = new Scraper(_singleton);\n\n        return this[_singleton]\n    }\n\n    /**\n     * Used to destroy the current instance of the class (it's a Singleton).\n     * Particularly useful for testing.\n     */\n    static destroyInstance() {\n        this[_singleton] = null;\n    }\n\n    /**\n     * Adds a template to the scraper.\n     *\n     * @param {object} template - The properties of the template, including name, matchesFormat, interval and callback.\n     */\n    addTemplate(template) {\n        if (!template.name) throw new Error('Template name is missing.');\n        if (!template.callback) throw new Error('Template callback is missing.');\n        if (!template.matchesFormat) throw new Error('Template matchesFormat property is missing.');\n        if (template.name in this.templates) throw new Error('Template already exists.');\n\n        if (!('interval' in template)) template.interval = 0;\n\n        this.templates[template.name] = template;\n    }\n\n    /**\n     * Retrieves the current templates used by the scraper.\n     *\n     * @returns {{}|*} - An array of objects.\n     */\n    getTemplates() {\n        return this.templates;\n    }\n\n    /**\n     * Sets the options for current instance.\n     *\n     * @param options {Object}\n     */\n    setOptions(options) {\n        this.options = options;\n    }\n\n    /**\n     * Retrieves the current options used by the scraper.\n     *\n     * @returns options {Object}\n     */\n    getOptions() {\n        return this.options;\n    }\n\n    /**\n     * Retrieves the current queue.\n     *\n     * @returns {*} - The queue.\n     */\n    getQueue() {\n        return this.deque;\n    }\n\n    /**\n     * Adds one or multiple URLs to the queue.\n     *\n     * @param urls {Array|String} - An array of URLs or a single URL as a string.\n     * @param priority {Number} - 0 or 1; if 1, then it will be immediately scraped, otherwise it will get in line.\n     */\n    queue(urls, priority) {\n        if (!priority) priority = 0;\n\n        if (_.isArray(urls)) {\n            urls.forEach(url => {\n               this.deque.push({url: url, priority: priority});\n            });\n        }\n        else {\n            this.deque.push({url: urls, priority: priority});\n        }\n    }\n\n    /**\n     * Retrives the waiting times (in ms) for all templates.\n     */\n    getWaitTimes() {\n        var that = this;\n        let waitTimes = {};\n        _.forEach(this.templates, function(template) {\n            let waitTime = (template.lastUsed - Date.now() + that._determineInterval(template)) || 0; // 0 for when the template was not used\n            waitTimes[template.name] = Math.max(waitTime, 0);\n        });\n        return waitTimes;\n    }\n\n    /**\n     *\n     * Starts the whole process of looping through the queue.\n     *\n     * @param options {Object} (optional)\n     */\n    start(options) {\n        if (options) this.options = options;\n\n        setTimeout(this._processNextInQueue.bind(this), 0);\n    }\n\n    /**\n     * Processes one element of the queue at a time.\n     *\n     * Calls itself recursively, so it should never stop trying to process stuff in the queue,\n     * for as long as the application is running.\n     *\n     * @private\n     */\n    _processNextInQueue() {\n        let that = this;\n\n        if (this.deque.length > 0) {\n            let queueEntry = this.deque.shift();\n\n            let nextURL = queueEntry.url;\n            let nextURLPriority = queueEntry.priority;\n\n            /* Identify the proper callback to be used once the results come in. */\n            let matchingTemplate = _.find(this.templates, function(template) {\n                return template.matchesFormat(nextURL);\n            });\n\n            if (matchingTemplate === undefined) {\n                that.emit('unmatched', nextURL);\n            }\n            else {\n\n                let interval = that._determineInterval(matchingTemplate);\n\n                /*\n                 * Computing how much time is needed until the next request for this specific\n                 * tuple (url, template) should happen. However, this keeps track of two different\n                 * streams: the priority URLs and the regulars. In both cases, it will try to\n                 * respect the interval set via the template or this.options.\n                 *\n                 * Assuming we have the following URLs coming in at the same time- format url(priority):\n                 *\n                 * url1(0), url2(0), url3(1), url4(1)\n                 *\n                 * Then url1 and url3 will execute at the same time, and so will url2 and url4, each pair\n                 * after the interval set via templates or this.options.\n                 */\n                let waitTime;\n                if (nextURLPriority === 0 && matchingTemplate.lastUsed) {\n                    if ((matchingTemplate.lastUsed + interval) < Date.now())\n                        waitTime = 0;\n                    else\n                        waitTime = (matchingTemplate.lastUsed + interval) - Date.now();\n                }\n                else if (nextURLPriority !== 0 && matchingTemplate.lastUsedPriority) {\n                    if ((matchingTemplate.lastUsedPriority + interval) < Date.now())\n                        waitTime = 0;\n                    else\n                        waitTime = (matchingTemplate.lastUsedPriority + interval) - Date.now();\n                }\n                else {\n                    waitTime = 0;\n                }\n\n                debug(matchingTemplate.name + ' - ' + matchingTemplate.lastUsed + ' - ' + waitTime);\n\n                /* Keeping track of when the last request to a URL matching the current template\n                 * has been made. This is possible to be a date in the future and is NOT precise\n                 * to the millisecond, but quite close.\n                 *\n                 * There are two cases here:\n                 *  - the link is a priority (priority > 0)\n                 *  - the link is a regular link\n                 *\n                 *  If the link is either one, it will update lastUsed because this will help with\n                 *  balancing the number of requests to being approximately the average imposed by\n                 *  the template's interval.\n                 *\n                 *  If the link has priority > 0, then it will update lastUsedPriority too because\n                 *  we don't want priority links to start 100 requests at the same time.\n                 */\n                matchingTemplate.lastUsed = Date.now() + waitTime;\n                if (nextURLPriority !== 0) matchingTemplate.lastUsedPriority = Date.now() + waitTime;\n\n                debug('Next URL (' + waitTime + ' milliseconds wait time) is - ' + nextURL);\n\n                /*  */\n                if (nextURLPriority > 0) waitTime = 0;\n\n                setTimeout(function () {\n                    that._makeRequest(nextURL, matchingTemplate);\n                }, waitTime);\n\n            }\n        }\n\n        setTimeout(this._processNextInQueue.bind(this), 0);\n    }\n\n    /**\n     * Makes a request to a specific URL and then applies the callback specified in its template.\n     *\n     * @param {String} url - An URL to be requested.\n     * @param {Object} template - The corresponding template matching the URL provided.\n     * @private\n     */\n    _makeRequest(url, template) {\n        /* TODO: take care of other responses than 200. */\n\n        let that = this;\n\n        request.get(url, function (error, response, body) {\n            if (!error && response.statusCode === 200) {\n                debug('Got results for ' + url);\n                let result = template.callback(url, body, cheerio.load(body));\n                that.emit('result', _.merge(result, { url: url, template: template }));\n            }\n        });\n    }\n\n    /**\n     * Determines the interval to wait in-between requests for a particular template.\n     *\n     * @param template\n     * @private\n     */\n    _determineInterval(template) {\n        if (this.options.interval)\n            return this.options.interval;\n        else if (this.options.maxInterval)\n            return Math.min(this.options.maxInterval, template.interval);\n        else\n            return template.interval;\n    }\n}\n\nexport default Scraper;"]}