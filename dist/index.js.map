{"version":3,"sources":["src/index.js"],"names":[],"mappings":"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","file":"src/index.js","sourcesContent":["'use strict';\n\nimport Deque from 'collections/deque';\nimport * as request from 'request';\nimport * as _ from 'lodash';\nimport * as cheerio from 'cheerio';\nvar debug = require('debug')('Scraper');\nvar EventEmitter = require('events').EventEmitter;\n\nlet _singleton = Symbol();\n\n/**\n *\n * Singleton class used to scrape websites based on templates and a queue.\n *  - the queue contains the URLs which will be retrieved and then processed as defined by its matching template\n *  - a template is a set of rules which dictate how often a certain type of website can be accessed and what\n *    happens with its response\n *\n * A more hands-on example:\n * You want to scrape data from amazon.com, so what you have to do is to instantiate the Scraper class, add a template\n * and then a couple of pages in the queue that you want scraped.\n *\n * ------------------------------------------------------------------------\n * var scraper = Scraper.instance;\n * scraper.addTemplate({\n *   name: 'Amazon',\n *   matchesFormat: function(url) {\n *       return url.toLowerCase().indexOf('amazon.com') !== -1;\n *   },\n *   callback: function(body, $) {\n *       return { body: body, provider: 'CNN' };\n *   },\n *   interval: 1000\n * });\n *\n * scraper.queue('https://www.amazon.com/product/whatever');\n * ------------------------------------------------------------------------\n *\n */\nclass Scraper extends EventEmitter {\n\n    constructor(singletonToken) {\n        super();\n        if (_singleton !== singletonToken)\n            throw new Error('Scraper is a singleton class, cannot instantiate directly.');\n\n        this.templates = {};\n        this.deque = new Deque();\n    }\n\n    static get instance() {\n        if(!this[_singleton])\n            this[_singleton] = new Scraper(_singleton);\n\n        return this[_singleton]\n    }\n\n    /**\n     * Used to destroy the current instance of the class (it's a Singleton).\n     * Particularly useful for testing.\n     */\n    static destroyInstance() {\n        this[_singleton] = null;\n    }\n\n    /**\n     * Adds a template to the scraper.\n     *\n     * @param {object} template - The properties of the template, including name, matchesFormat, interval and callback.\n     */\n    addTemplate(template) {\n        if (!template.name) throw new Error('Template name is missing.');\n        if (!template.callback) throw new Error('Template callback is missing.');\n        if (!template.matchesFormat) throw new Error('Template matchesFormat property is missing.');\n        if (template.name in this.templates) throw new Error('Template already exists.');\n\n        if (!('interval' in template)) template.interval = 0;\n\n        this.templates[template.name] = template;\n    }\n\n    /**\n     * Retrieves the current templates used by the scraper.\n     *\n     * @returns {{}|*} - An array of objects.\n     */\n    getTemplates() {\n        return this.templates;\n    }\n\n    /**\n     * Retrieves the current queue.\n     *\n     * @returns {*} - The queue.\n     */\n    getQueue() {\n        return this.deque;\n    }\n\n    /**\n     * Adds one or multiple URLs to the queue.\n     *\n     * @param urls {Array|String} - An array of URLs or a single URL as a string.\n     */\n    queue(urls) {\n        if (_.isArray(urls)) {\n            urls.forEach(url => {\n               this.deque.push(url);\n            });\n        }\n        else {\n            this.deque.push(urls);\n        }\n    }\n\n    /**\n     * Starts the whole process of looping through the queue.\n     */\n    start() {\n        setTimeout(this._processNextInQueue.bind(this), 0);\n    }\n\n    /**\n     * Processes one element of the queue at a time.\n     *\n     * Calls itself recursively, so it should never stop trying to process stuff in the queue,\n     * for as long as the application is running.\n     *\n     * @private\n     */\n    _processNextInQueue() {\n        let that = this;\n\n        if (this.deque.length > 0) {\n            let nextURL = this.deque.shift();\n\n            /* Identify the proper callback to be used once the results come in. */\n            let matchingTemplate = _.find(this.templates, function(template) {\n                return template.matchesFormat(nextURL);\n            });\n\n            if (matchingTemplate === undefined) {\n                that.emit('unmatched', nextURL);\n            }\n            else {\n\n                let interval = matchingTemplate.interval;\n\n                /*\n                 * Computing how much time is needed until the next request for this specific\n                 * tuple (url, template) should happen.\n                 *\n                 * If the last request happened less time ago than the specified interval or didn't\n                 * happen at all until now, then run it straight away.\n                 *\n                 * Otherwise, set it to run after a while, so that it matches the minimum interval specified.\n                 */\n                let waitTime;\n                if (matchingTemplate.lastUsed) { // basically it it's undefined\n                    if ((matchingTemplate.lastUsed + interval) < Date.now())\n                        waitTime = 0;\n                    else\n                        waitTime = (matchingTemplate.lastUsed + interval) - Date.now();\n                } else {\n                    waitTime = 0;\n                }\n\n                debug(matchingTemplate.name + ' - ' + matchingTemplate.lastUsed + ' - ' + waitTime);\n\n                /* Keeping track of when the last request to a URL matching the current template\n                 * has been made. This is possible to be a date in the future and is NOT precise\n                 * to the millisecond, but quite close. */\n                matchingTemplate.lastUsed = Date.now() + waitTime;\n\n                debug('Next URL (' + waitTime + ' milliseconds wait time) is - ' + nextURL);\n\n                setTimeout(function () {\n                    that._makeRequest(nextURL, matchingTemplate);\n                }, waitTime);\n\n            }\n        }\n\n        setTimeout(this._processNextInQueue.bind(this), 0);\n    }\n\n    /**\n     * Makes a request to a specific URL and then applies the callback specified in its template.\n     *\n     * @param {String} url - An URL to be requested.\n     * @param {Object} template - The corresponding template matching the URL provided.\n     * @private\n     */\n    _makeRequest(url, template) {\n        /* TODO: take care of other responses than 200. */\n\n        let that = this;\n\n        request.get(url, function (error, response, body) {\n            if (!error && response.statusCode == 200) {\n                debug('Got results for ' + url);\n                let result = template.callback(body, cheerio.load(body));\n                that.emit('result', _.merge(result, { url: url, template: template }));\n            }\n        });\n    }\n}\n\nexport default Scraper;"]}